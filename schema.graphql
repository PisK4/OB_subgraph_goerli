type ChallengeInfoUpdated @entity(immutable: true) {
  id: Bytes!
  challengeId: Bytes! # bytes32
  challengeInfo_sourceTxFrom: BigInt! # uint256
  challengeInfo_sourceTxTime: BigInt! # uint64
  challengeInfo_challenger: Bytes! # address
  challengeInfo_freezeToken: Bytes! # address
  challengeInfo_challengeUserRatio: BigInt! # uint64
  challengeInfo_freezeAmount0: BigInt! # uint256
  challengeInfo_freezeAmount1: BigInt! # uint256
  challengeInfo_challengeTime: BigInt! # uint64
  challengeInfo_abortTime: BigInt! # uint64
  challengeInfo_verifiedTime0: BigInt! # uint64
  challengeInfo_verifiedTime1: BigInt! # uint64
  challengeInfo_verifiedDataHash0: Bytes! # bytes32
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# using entity, binding in contract Event
type ColumnArrayUpdated @entity(immutable: true) {
  id: ID!
  impl: Bytes # address
  columnArrayHash: Bytes # bytes32
  dealers: [Bytes!] # address[]
  ebcs: [Bytes!] # address[]
  chainIds: [BigInt!] # uint64[]
  mdc: MDC! @derivedFrom(field: "columnArrayUpdated") # MDC
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# unused entity, but it's binding in contract Event, so we need to define it
type ResponseMakersUpdated @entity(immutable: true) {
  id: Bytes!
  # impl: Bytes! # address
  # responseMakers: [BigInt!] # uint256[]
  # blockNumber: BigInt!
  # blockTimestamp: BigInt!
  # transactionHash: Bytes!
}

# unused entity, but it's binding in contract Event, so we need to define it
type RulesRootUpdated @entity(immutable: true) {
  id: Bytes!
  # impl: Bytes! # address
  # ebc: Bytes! # address
  # rootWithVersion_root: Bytes! # bytes32
  # rootWithVersion_version: BigInt! # uint32
  # blockNumber: BigInt!
  # blockTimestamp: BigInt!
  # transactionHash: Bytes!
  # input: Bytes!
}

# unused entity, but it's binding in contract Event, so we need to define it
type SpvUpdated @entity(immutable: true) {
  id: Bytes!
  # impl: Bytes! # address
  # chainId: BigInt! # uint64
  # spv: Bytes! # address
  # blockNumber: BigInt!
  # blockTimestamp: BigInt!
  # transactionHash: Bytes!
}

# unused entity, but it's binding in contract Event, so we need to define it
type MDCCreated @entity(immutable: true) {
  id: Bytes!
  # maker: Bytes! # address
  # mdc: Bytes! # address
  # blockNumber: BigInt!
  # blockTimestamp: BigInt!
}

# customed using entity
type MDC @entity {
  id: ID! # MDC ADDRESS
  owner: Bytes! # address
  responseMakers: [Bytes!] # address[]
  # spvs: [Bytes!] # address[]
  chainIds: [BigInt!] # uint64[]
  dealers: [Bytes!] # address[]
  bindEBCs: [MDCBindEBC!]! # MDCBindEBC
  bindSPVs: [MDCBindSPV!]! # MDCBindSPV
  # columnArrayHash: Bytes # bytes32
  columnArrayUpdated: [ColumnArrayUpdated!]! # ColumnArrayUpdated 
  factory: [FactoryManger!]! @derivedFrom(field: "mdcs") 
  ebc: [EBC!]! @derivedFrom(field: "mdcList") # EBC
  
  createblockNumber: BigInt!
  createblockTimestamp: BigInt!
  createtransactionHash: Bytes!
  lastestUpdatetransactionHash: Bytes!

}

# customed using entity
type DealerManager @entity{
  id: ID! # dealer ID
  dealers: [Bytes!]! # address[]
  dealerCounts: BigInt!
}

# customed using entity
type FactoryManger @entity{
  id: Bytes!  # factory address
  mdcs: [MDC!]! # MDC[]
  mdcCounts: BigInt!
  lastestUpdateHash: Bytes!
  lastestUpdateTimestamp: BigInt!
  lastestUpdateBlockNumber: BigInt!
}

# customed using entity
type EBCManager @entity{
  id: ID! 
  ebcCounts: BigInt!
  ebcs: [EBC!]! # ebc entity
  manger: ChainTokenEBCManager! @derivedFrom(field: "ebcManager") # ChainTokenEBCManager
  
  lastestUpdateHash: Bytes!
  lastestUpdateTimestamp: BigInt!
  lastestUpdateBlockNumber: BigInt!
}

# customed using entity
type MDCBindEBC @entity{
  id: ID! # mdc address - ebc address
  ebc: Bytes! # ebc address
  rulesWithRootVersion: [ruleTypes!]! 
  mdc: MDC! @derivedFrom(field: "bindEBCs") # MDC
  lastestUpdateHash: Bytes!
  lastestUpdateTimestamp: BigInt!
  lastestUpdateBlockNumber: BigInt!
}

# customed using entity
type MDCBindSPV @entity{
  id: ID! # mdc address - ChainId
  chainId: BigInt # uint64
  spv: Bytes # spv address
  mdc: MDC! @derivedFrom(field: "bindSPVs") # MDC
}

# customed using entity
type EBC @entity {
  id: ID! #ebc address
  mdcList: [MDC!]! # list all mdc!! who bind this ebc
  statuses: Boolean!
  ebcManager: EBCManager! @derivedFrom(field: "ebcs") # ebcManager entity
  lastestUpdatetransactionHash: Bytes!
}

# customed using entity
type ruleTypes @entity {  #contain all rules
  id: ID!
  rules: [rule!]! # all rules   
  mdcBindebc: MDCBindEBC! @derivedFrom(field: "rulesWithRootVersion") # MDCBindEBC
  root: Bytes! # bytes32
  version: Int! # uint32  
}

# customed using entitys
type rule @entity { # only one rule in ruleTypes
  id: ID!
  chain0: BigInt! # uint64
  chain1: BigInt! # uint64
  chain0Status: Int! # uint8
  chain1Status: Int! # uint8
  chain0Token: Bytes! # Address
  chain1Token: Bytes! # Address
  chain0minPrice: BigInt! # uint128
  chain1minPrice: BigInt! # uint128
  chain0maxPrice: BigInt! # uint128
  chain1maxPrice: BigInt! # uint128
  chain0WithholdingFee: BigInt! # uint128
  chain1WithholdingFee: BigInt! # uint128
  chain0TradeFee: Int! # uint16
  chain1TradeFee: Int! # uint16
  chain0ResponseTime: Int! # uint32
  chain1ResponseTime: Int! # uint32
  chain0CompensationRatio: Int! # uint32
  chain1CompensationRatio: Int! # uint32
  ruletypes: ruleTypes! @derivedFrom(field: "rules") # ruleTypes
}

# type ChainInfo @entity {
#   id: ID!
#   spv: [Bytes!]! # address[]
#   batchLimit: BigInt # uint192
#   minVerifyChallengeSourceTxSecond: BigInt # uint64
#   maxVerifyChallengeSourceTxSecond: BigInt # uint64
#   minVerifyChallengeDestTxSecond: BigInt # uint64
#   maxVerifyChallengeDestTxSecond: BigInt # uint64
# }

# using entity, binding in contract Event
type ChainInfoUpdated @entity{
  id: ID!
  spv: [Bytes!]! # address[]
  batchLimit: BigInt # uint192
  minVerifyChallengeSourceTxSecond: BigInt # uint64
  maxVerifyChallengeSourceTxSecond: BigInt # uint64
  minVerifyChallengeDestTxSecond: BigInt # uint64
  maxVerifyChallengeDestTxSecond: BigInt # uint64
  manger: ChainTokenEBCManager! @derivedFrom(field: "chainInfoManager") # ChainTokenEBCManager
  lastestUpdateBlockNumber: BigInt!
  lastestUpdateTimestamp: BigInt!
  lastestUpdateHash: Bytes!
}

# using entity, binding in contract Event
type ChainTokenUpdated @entity(immutable: true) {
  id: ID!
  inputId: BigInt # uint64
  token: BigInt # uint
  mainnetToken: Bytes # address
  decimals: Int # uint8
  manager: ChainTokenEBCManager! @derivedFrom(field: "tokenManager") # ChainTokenEBCManager
  blockNumber: BigInt
  blockTimestamp: BigInt
  transactionHash: Bytes
}

# customed using entity
type ChainTokenEBCManager @entity{
  id: ID!  # Manger ID
  chainInfoManager: ChainInfoUpdated! # ChainInfo
  ebcManager: EBCManager! # EBCs
  tokenManager: ChainTokenUpdated! # ChainToken
}

type ChallengeUserRatioUpdated @entity(immutable: true) {
  id: Bytes!
  challengeUserRatio: BigInt! # uint64
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EbcsUpdated @entity(immutable: true) {
  id: Bytes!
  ebcs: [Bytes!]! # address[]
  statuses: [Boolean!]! # bool[]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type FeeChallengeSecondUpdated @entity(immutable: true) {
  id: Bytes!
  feeChallengeSecond: BigInt! # uint64
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type FeeTakeOnChallengeSecondUpdated @entity(immutable: true) {
  id: Bytes!
  feeTakeOnChallengeSecond: BigInt! # uint64
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MaxMDCLimitUpdated @entity(immutable: true) {
  id: Bytes!
  maxMDCLimit: BigInt! # uint64
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MinChallengeRatioUpdated @entity(immutable: true) {
  id: Bytes!
  minChallengeRatio: BigInt! # uint64
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type OwnershipTransferred @entity(immutable: true) {
  id: Bytes!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProtocolFeeUpdated @entity(immutable: true) {
  id: Bytes!
  protocolFee: BigInt! # uint64
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type SubmitterFeeUpdated @entity(immutable: true) {
  id: Bytes!
  submitter: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
